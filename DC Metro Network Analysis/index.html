---
layout: default
title: Kevin Craig
---

<div class="blurb">
	<h1> -- Work in Progress -- DC Metro Network Analysis</h1>
	<p>
		Network analysis is often applied to the social and online systems around us, ex. Facebook friend networks. A more concrete example of a physical network is a metro system.
	</p>
	<p>
		The DC metro is a straight forward example of a fully connected network system. The network can be described as nodes (stations) and edges (railway paths). Some stations are more important to the network than others because they are connected to many other stations.
	</p>
	<p>
		How can we understand the importance of each metro station? Metro nodes can be described in three main metrics: 
	</p>
	<p>
			1. <b>Degree:</b> How many other stations a rider can reach from a given station
			2. <b>Betweenness Centrality:</b> How much control a station has on the ability for a rider to reach other stations
			3. <b>Closeness Centrality:</b> How close a given station is to other stations
	</p>
		
		<li>C</li>
	</ol>
	<p>
		In order to understand the degree, betweenness, and closeness of a given station, we need to represent the metro system in a dataset that the computer can understand. The best way to do this is through an adjacency matrix of stations. Luckily WMATA provides a series of API products that make fetching station and line data pretty easy. Code on how to build the adjacency matrix is on my github here. I was surprised this data was not available anywhere I looked online, so I hope it is useful for anyone else who wants to explore metro analysis.
	</p>
	<p>
		Once the network is expressed in an adjacency matrix, Python can help us calculate the network statistics we discussed above. Finally we can overlay those stats on top of network line and station shapefiles provided by WMATA and visualized via geopandas.
	</p>			 
	

</div><!-- /.blurb -->
<div style="width: 50%; margin: 0 auto;">
	<iframe src="bokeh_wmata.html" frameborder="0" width="600" height="490"	></iframe>
</div>

<div class="blurb">
	<p>
		Before I started this project I assumed Metro Center would be the most "important" station based on my ridership patterns, but it looks like L'Enfant Plaza takes the cake! L'Enfant has a degree of 5, betweenness of .571 and closeness of .144 not to mention an underground food court. Honorable mention to Pentagon, the most important station outside of DC in terms of betweenness and closeness centrality.
	</p>
	<p>
		Instead of using set shapefiles to draw the network, what if we let the computer decide how it looks? Force directed algorithms allow us to visualize networks as a nodes and edges that repel against each other based on a given charge. The D3 javascript library is a popular tool for building force directed networks - I implemented D3 to build a free-flowing DC metro system below.
	</p>
</div>

<div style="width:960; margin:0 auto;">

<style>

	.links line {
	  stroke: #999;
	  stroke-opacity: 0.6;
	}
	
	.nodes circle {
	  stroke: #fff;
	  stroke-width: 1.5px;
	}
	
	text {
	  font-family: sans-serif;
	  font-size: 8px;
	}
	
	
	</style>
	
	<!-- Use charge -inf -- 0 to change network distribution-->
	
	<svg width="960" height="800"></svg> 
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script>
	
	var svg = d3.select("svg"),
		width = +svg.attr("width"),
		height = +svg.attr("height");
	
	var color = d3.scaleOrdinal(d3.schemeCategory20);
	
	var simulation = d3.forceSimulation()
		.force("link", d3.forceLink().id(function(d) { return d.id; }))
		.force("charge", d3.forceManyBody().strength(-15))
		.force("center", d3.forceCenter(width / 2, height / 2));
	
	d3.json("wmata.json", function(error, graph) {
	  if (error) throw error;
	
	  var link = svg.append("g")
		  .attr("class", "links")
		.selectAll("line")
		.data(graph.links)
		.enter().append("line")
		  .attr("stroke-width", function(d) { return Math.sqrt(d.degree); });
	
	  var node = svg.append("g")
		  .attr("class", "nodes")
		.selectAll("g")
		.data(graph.nodes)
		.enter().append("g")
		
	  var circles = node.append("circle")
		  .attr("r", function(d) { return d.degree * 3; })
		  .attr("fill", function(d) { return color(d.degree); })
		  .call(d3.drag()
			  .on("start", dragstarted)
			  .on("drag", dragged)
			  .on("end", dragended));
	
	  var lables = node.append("text")
		  .text(function(d) {
			return d.id;
		  })
		  .attr('x', 6)
		  .attr('y', 3);
	
	  node.append("title")
		  .text(function(d) { return d.id; });
	
	  simulation
		  .nodes(graph.nodes)
		  .on("tick", ticked);
	
	  simulation.force("link")
		  .links(graph.links);
	
	  function ticked() {
		link
			.attr("x1", function(d) { return d.source.x; })
			.attr("y1", function(d) { return d.source.y; })
			.attr("x2", function(d) { return d.target.x; })
			.attr("y2", function(d) { return d.target.y; });
	
		node
			.attr("transform", function(d) {
			  return "translate(" + d.x + "," + d.y + ")";
			})
	  }
	});
	
	function dragstarted(d) {
	  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
	  d.fx = d.x;
	  d.fy = d.y;
	}
	
	function dragged(d) {
	  d.fx = d3.event.x;
	  d.fy = d3.event.y;
	}
	
	function dragended(d) {
	  if (!d3.event.active) simulation.alphaTarget(0);
	  d.fx = null;
	  d.fy = null;
	}
	
	</script>
</div>